<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../assets/css/style.css">
    <link rel="stylesheet" href="../../assets/css/article.css">
    <title>Hacking my childhood game -Benaissa Zaki</title>
</head>

<body>
    <main>
        <article>
            <ul class="breadcrumb">
                <li><a href="../../index.html">Home</a></li>
                <li><a href="../index.html">Blog</a></li>
                <li>Hacking my childhood game</li>
            </ul>

            <h1>Hacking my childhood game</h1>

            <p>I recently started to explore Game Hacking, and I find it fascinating. The thought process is quite
                different from programming since it asks ‚ÄúHow was this created?‚Äù instead of ‚ÄúHow do I create this?‚Äù.
            </p>
            <p>In this blog post, I will detail the step-by-step process I followed to change the behavior of one of
                my favorite video games.</p>

            <h2>Tools used</h2>
            <ul>
                <li>Windows 11</li>
                <li>Cheat Engine</li>
                <li>x32dbg</li>
                <li>The Lord of the Rings: Battle for Middle Earth II</li>
            </ul>

            <h2>The objective</h2>

            <p>One of the games I spent a lot of time on in my childhood was The Lord of the Rings: Battle for
                Middle Earth II. It is a Real-Time Strategy (RTS) game, where you can control units, gather
                resources, and build bases to beat the enemy on the battlefield.</p>

            <p>But the number of units you can recruit is not unlimited. Once you reach the Command Point Limit
                (CPLimit) you cannot recruit more troops.&nbsp;</p>

            <p>CPLimit can be increased by building special buildings like farms, but the game doesn‚Äôt allow CPLimit
                to go higher than 1000 (which we will call CPMax) no matter how many farms you have.</p>

            <p>So the goal is to do some reverse engineering in order to allow CPLimit to go beyond CPMax, which
                ought to make the game even more interesting.</p>

            <p>Note: This can probably be done in 5 mins by modifying an option in some game file. But you don‚Äôt
                really learn much by doing so.</p>

            <h2>1- Finding CPLimit‚Äôs memory address</h2>

            <figure>
                <img fetchpriority="high" decoding="async" src="./assets/img/1-Initial-CPL.webp" alt="">
            </figure>

            <p>At the start of the game, CPLimit=800.</p>

            <p>To find the address of the variable in memory, we fire up Cheat Engine and attach it to the game‚Äôs
                process.</p>

            <p>We enter 800 in the ‚ÄúValue‚Äù input box, and hit ‚ÄúFirst scan‚Äù:</p>

            <figure>
                <img decoding="async" src="./assets/img/2-Initial-Mem-search.webp" alt="">
            </figure>

            <p>As we can see on the left, there are 846 variables containing that value.</p>

            <p>To narrow the results, I will build a farm in the game which increases CPLimit‚Äôs value by 50.</p>

            <p>I will then type the new value and hit ‚ÄúNext scan‚Äù:</p>

            <figure>
                <img decoding="async" src="./assets/img/3-Second-Mem-search.webp" alt="">
            </figure>

            <p>And there it is, CPLimit‚Äôs address is 04E39748 in Hexadecimal.</p>

            <p>Now, if I were to quit the current game and launch a new one, the address would be different. That‚Äôs
                how the computer‚Äôs memory works.</p>

            <p>I will try to change CPLimit‚Äôs value directly from Cheat Engine and set it to 1000:</p>

            <figure>
                <img loading="lazy" decoding="async" src="./assets/img/4-Mem-change.webp" alt="">
            </figure>

            <p>However, the game instantly sets it back to 850:</p>

            <figure>
                <img loading="lazy" decoding="async" src="./assets/img/5-Mem-unchanged.webp" alt="">
            </figure>

            <p>Well, this gives us an idea of how the game works. We can assume that it does not blindly trust the
                value in memory and that CPLimit is probably constantly recalculated.</p>

            <h2>2- Inspecting the game‚Äôs code</h2>

            <p>Now that we have our address, we can close Cheat Engine and open x32dbg, and attach it to the game‚Äôs
                process:</p>

            <figure>
                <img loading="lazy" decoding="async" src="./assets/img/6-Attaching-x32.webp" alt="">
            </figure>

            <p>Weirdly enough, there are 2 processes related to the game. I suppose that the first one is the actual
                game, while the second one is its launcher. Remember that.</p>

            <p>So we choose the first process. And we are greeted with this scary-looking interface:</p>

            <figure>
                <img loading="lazy" decoding="async" src="./assets/img/6-x32dbg.png" alt="">
            </figure>

            <p>Here are the 3 important sections we need to know:</p>

            <ol>
                <li>This section contains the game‚Äôs code. As we can see, it is not in a high-level language such as
                    C but in assembly, which is just a small step above binary.<br>The first column contains the
                    instruction‚Äôs address, the second contains the instruction encoded in Hexadecimal, the third
                    contains the instruction in assembly, and the fourth contains the instruction‚Äôs label.</li>
                <li>Here are the CPU registers and their current values. These values will of course keep changing
                    during the program‚Äôs execution.</li>
                <li>Here is the memory‚Äôs content with their address in hexadecimal.</li>
            </ol>

            <p>Now, as a starting point, we will look for our CPLimit variable in the memory section by</p>

            <p><strong>Left-clicking &gt; Go to &gt; Expression</strong> and enter the address we found earlier
                (04E39748):</p>

            <figure>
                <img loading="lazy" decoding="async" src="./assets/img/7-Hex-dump.png" alt="">
            </figure>

            <p>As a start, we will try to find the code that is responsible for modifying this variable whenever it
                is supposed to change.</p>

            <p>I will left-click on it and <strong>Breakpoint &gt; Hardware &gt; Write &gt; DWORD.</strong></p>

            <p>This will create a breakpoint on any instruction that modifies this address. Meaning that the program
                will execute normally, but when it reaches an instruction that writes something in this address, the
                execution will pause.</p>

            <p>In the game, I will again build another farm to modify CPLimit, hence triggering our breakpoint. And
                indeed the game pauses here:</p>

            <figure>
                <img loading="lazy" decoding="async" src="./assets/img/8-Change-CPL.webp" alt="">
            </figure>

            <p>‚Äú<strong><code>mov dword ptr ds:[esi+10], edi</code></strong>‚Äù writes to our address. To understand
                why, we must understand this code.</p>

            <p>The <strong><code>mov</code></strong> instruction has the following syntax:
                <strong><code>‚Äúmov destination, source‚Äù</code></strong>. And it moves the value from
                <strong><code>source</code></strong> to <code><strong>destination</strong></code>.
            </p>

            <p><strong><code>dword ptr ds:[X]</code></strong> refers to the memory location whose address is
                <strong><code>X</code></strong>.&nbsp;
            </p>

            <p><strong><code>esi</code></strong> and <strong><code>edi</code></strong> are both CPU registers.</p>

            <p>In short<code><strong> ‚Äúmov dword ptr ds:[esi+10], edi‚Äù</strong></code> means ‚ÄúMove the value of the
                <strong><code>edi</code></strong> register to the memory location
                <strong><code>esi+10</code></strong>.
            </p>

            <p>Okay, but what does it have to do with CPLimit?</p>

            <p>If we take a look at the registers‚Äô values:</p>

            <figure>
                <img loading="lazy" decoding="async" src="./assets/img/8-Change-CPL-Reg.png" alt="">
            </figure>

            <p>We notice that <strong><code>esi+10 = 04E39738 + 10 = 04E39748</code></strong> = CPLimit‚Äôs address.
            </p>

            <p>And <strong><code>edi = 384</code></strong> which is the hexadecimal value of 900, the new value of
                CPLimit.</p>

            <p>Using the debugger, we can now execute the program instruction by instruction.</p>

            <p>We step out of the current function, and we find the instruction that called it:</p>

            <figure><img loading=" lazy" decoding="async" src="./assets/img/9-HandleCP.webp" alt="">
            </figure>

            <p><strong><code>call &lt;ADDRESS&gt;</code></strong> is the instruction to call the function located at
                <strong><code>&lt;ADDRESS&gt;</code></strong>.
            </p>

            <p>We suppose that this function handles something related to CPLimit. To confirm that, we set a
                breakpoint at the call instruction, and we let the program run freely.</p>

            <p>The breakpoint is immediately triggered, which probably means that this function is called with every
                frame of the game.</p>

            <p>We step inside the function. And instead of analyzing every instruction, we keep an eye on the
                registers‚Äô values.</p>

            <p>We keep stepping through the function‚Äôs code until we notice something here:</p>

            <figure>
                <img loading="lazy" decoding="async" src="./assets/img/9-CPL-loaded.webp" alt="">
            </figure>


            <p>After stepping over this other function, the register <strong><code>eax</code></strong> contains the
                value 900, which is the current value of CPLimit.</p>

            <p>So there must be something important going on in this function, I set a breakpoint on it, and let the
                program run. And when it is triggered, I step into it:</p>

            <figure>
                <img loading="lazy" decoding="async" src="./assets/img/10-CPLimit-calculated.webp" alt="">
            </figure>

            <p>I notice that after executing <strong><code>add ebx, dword ptr ds:[esi+4]</code></strong>, ebx
                contains CPLimit, which is currently 900.&nbsp;</p>

            <p>But most interestingly, it did not just fetch its value from the memory address that we found earlier
                using Cheat Engine.</p>

            <p>It was calculated from 2 other values located in memory at the
                addresses<strong><code> [esi+C]</code></strong> (C is 12 in hexadecimal) and
                <strong><code>[esi + 4]</code></strong>.&nbsp;
            </p>

            <p>Currently,<strong><code> [esi+C] = 150</code></strong> and
                <strong><code>[esi+4] = 750</code></strong>.
            </p>

            <p>750 is the initial value of CPLimit when the player has no building.</p>

            <p>150 is because my buildings have increased my CP limit by 150. Both a citadel and a farm increase
                CPLimit by 50. Since I have a Citadel and 2 farms, then CPLimit is increased by 50 + 50*2 = 150.</p>

            <p>We keep stepping through the function until we reach this instruction:</p>

            <figure>
                <img loading="lazy" decoding="async" src="./assets/img/10-CPLimit-trimmer.webp" alt="">
            </figure>


            <p><strong><code>cmovg ebx, esi</code></strong> means here: if
                <strong><code>ebx &gt; esi</code></strong>, then put <strong><code>esi</code></strong>‚Äôs value into
                <strong><code>ebx</code></strong>.
            </p>

            <p>By inspecting the values of the registers, we see that <strong><code>esi</code></strong> currently
                contains 1000 which is the value of CPMax.</p>

            <p>This instruction makes sure that CPLimit cannot grow past that value, no matter how many farms we
                have. This is the culprit we have been looking for.</p>

            <p><strong><code>ebx</code></strong>‚Äôs value is later loaded into <strong><code>eax</code></strong></p>

            <p>In short, this is what this function does:</p>

            <pre>def calculateCPLimit():
    CPLimit = BaseCP + AdditionalCP
    if CPLimit &gt; CPmax:
        CPLimit = CPMax
        return CPLimit</pre>

            <p>(Yes, I know that Python uses snake_case)</p>

            <p>Now, our objective is clear: remove that if statement. Which translates in assembly to removing that
                <strong><code>cmovg ebx, esi</code></strong> instruction.<br>We can do that in x32dbg by
                <strong>Left-clicking on it &gt; DIsassembly, </strong>and we replace the instruction with
                <strong><code>nop</code></strong>, an instruction that does nothing. We also check the ‚ÄúFill with
                nops‚Äù option.
            </p>

            <figure>
                <img loading="lazy" decoding="async" src="./assets/img/11-Nopping-trimmer.webp" alt="">
            </figure>


            <p>We can see that it has been replaced with 3 nops, this is because the original instruction was 3
                bytes long, while a nop is 1 byte.</p>

            <p>Going back to the game, and after building 3 additional farms, we see the following result:</p>

            <figure>
                <img loading="lazy" decoding="async" src="./assets/img/12-Success.webp" alt="">
            </figure>


            <p>Yay!</p>

            <p>However, our change is not persistent. If we close the game now, we would have to open x32dbg and
                modify the code again.</p>

            <p>In the next article, we will solve that problem.</p>

            <p>But for the moment, I am going to enjoy the game the way 10-year-old me dreamed of. Surely now I will
                beat the Brutal difficulty with this unfair advantage?</p>

            <p>PS: I didn‚Äôt.</p>
            </div>
        </article>
    </main>
    <footer>
        <div id="credits">
            Made with üóø by <strong>Zaki Benaissa</strong>
        </div>
    </footer>
</body>

</html>
